<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
    	<link href="assets/css/style.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<script src="http://mrdoob.github.com/three.js/build/three.min.js"></script>
        
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script src="assets/js/three_r57.min.js"></script> 
        <script src="assets/js/controls/OrbitControls_r57.js"></script> 
        
        <script src="assets/js/utils/Detector.js"></script> 
        <script src="assets/js/utils/stats.min.js"></script> 
        <script src="assets/js/utils/tween.min.js"></script> 
		
		<script src="http://mrdoob.github.com/three.js/examples/js/shaders/CopyShader.js"></script>
		<script src="http://mrdoob.github.com/three.js/examples/js/shaders/SSAOShader.js"></script>
		
		<script src="http://mrdoob.github.com/three.js/examples/js/postprocessing/EffectComposer.js"></script>
		<script src="http://mrdoob.github.com/three.js/examples/js/postprocessing/RenderPass.js"></script>
		<script src="http://mrdoob.github.com/three.js/examples/js/postprocessing/MaskPass.js"></script>
		<script src="http://mrdoob.github.com/three.js/examples/js/postprocessing/ShaderPass.js"></script>
		
		<script>

			// workaround for chrome bug: http://code.google.com/p/chromium/issues/detail?id=35980#c12
			if ( window.innerWidth === 0 ) { window.innerWidth = parent.innerWidth; window.innerHeight = parent.innerHeight; }
							
			var container, stats, camera, scene, renderer, projector, controls;
			var group;
			var depthMaterial, depthTarget, composer;
			var clickobjects = [], hoverobjects = [], sprites = [];
			
			var objects = [], plane;
			var mouse = new THREE.Vector2(),
			offset = new THREE.Vector3(),
			INTERSECTED, SELECTED;

			init();
			animate();

			function init() {
				
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 10, 1000 );
				camera.position.z = 500;
				
				//////////////////////////////////
				//////// ORBIT CONTROLS //////////
				//////////////////////////////////
	
				controls = new THREE.OrbitControls( camera, container );
				controls.addEventListener( 'change', render );
				controls.maxPolarAngle = Math.PI/4.5; 
				controls.minDistance = 50;
				controls.maxDistance = 300;
				controls.enabled = false;

				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0xeeeeee, 0.002 );
				
				var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
				directionalLight.position.set( 0, 1, 0 );
				scene.add( directionalLight );
				
				var ambientLight = new THREE.AmbientLight( 0xcccccc );
				scene.add( ambientLight );

				//////////////////////////////////
				/////////// GEOMETRY /////////////
				//////////////////////////////////
					
				group = new THREE.Object3D();
				scene.add( group );
				
				var material = new THREE.MeshDepthMaterial( { side: THREE.DoubleSide, overdraw: true } );
				
				loader = new THREE.JSONLoader();
			
				loader.load( "assets/models/test.js", function( geometry, materials ) {
			
					buildings = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
					materials[0].wrapS = materials[0].wrapT = THREE.RepeatWrapping;
					buildings.scale.set( 1.5, 1.5, 1.5 );
					buildings.position.set( -500, -0.5, 0 );
					group.add( buildings );
					
					clickobjects.push( buildings );
					hoverobjects.push( buildings );
					
				} );
				
				texture = THREE.ImageUtils.loadTexture('assets/images/map.jpg', {}, function() {
					renderer.render(scene);
				})
				mapmaterial = new THREE.MeshBasicMaterial({map: texture})
				ground = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000, 8, 8 ), mapmaterial );
				ground.rotation.x += 270 * Math.PI / 180;
				scene.add( ground );
				
				objects.push( ground );
				
				plane = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true } ) );
				plane.visible = false;
				scene.add( plane );
				plane.rotation.x += 270 * Math.PI / 180;
				
				//////////////////////////////////
				//////////// SPRITES /////////////
				//////////////////////////////////
			
				sprite1 = makeTextSprite( " Section 1 ", 
					{ fontsize: 12, fontface: "Arial", borderColor: {r:0, g:0, b:0, a:1.0} } );
				sprite1.position.set(-90,50,90);
				scene.add( sprite1 );
				
				sprite2 = makeTextSprite( " Section 2 ", 
					{ fontsize: 12, fontface: "Arial", borderColor: {r:0, g:0, b:0, a:1.0} } );
				sprite2.position.set(90,50,90);
				scene.add( sprite2 );
				
				sprite3 = makeTextSprite( " Section 3 ", 
					{ fontsize: 12, fontface: "Arial", borderColor: {r:0, g:0, b:0, a:1.0} } );
				sprite3.position.set(90,50,-90);
				scene.add( sprite3 );
				
				sprite4 = makeTextSprite( " Section 4 ", 
					{ fontsize: 12, fontface: "Arial", borderColor: {r:0, g:0, b:0, a:1.0} } );
				sprite4.position.set(-90,50,-90);
				scene.add( sprite4 );
				
				sprites.push( sprite1, sprite2, sprite3, sprite4 );
				
				//////////////////////////////////
				//////////// RENDERER ////////////
				//////////////////////////////////
				
				projector = new THREE.Projector();

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
			
				container.appendChild( renderer.domElement );
			
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
			
				renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
			
				//
			
				window.addEventListener( 'resize', onWindowResize, false );
	
							
				//////////////////////////////////
				///////////// DEPTH //////////////
				//////////////////////////////////
				
				/*var depthShader = THREE.ShaderLib[ "depthRGBA" ];
				var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

				depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
				depthMaterial.blending = THREE.NoBlending;

				//////////////////////////////////
				////////////// SSAO //////////////
				//////////////////////////////////
				
				composer = new THREE.EffectComposer( renderer );
				composer.addPass( new THREE.RenderPass( scene, camera ) );

				depthTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
				
				var effect = new THREE.ShaderPass( THREE.SSAOShader );
				effect.uniforms[ 'tDepth' ].value = depthTarget;
				effect.uniforms[ 'size' ].value.set( window.innerWidth, window.innerHeight );
				effect.uniforms[ 'cameraNear' ].value = camera.near;
				effect.uniforms[ 'cameraFar' ].value = camera.far;
				effect.renderToScreen = true;
				composer.addPass( effect );
			*/	
			}
			
			//////////////////////////////////
			///////// SPRITE BUILDER /////////
			//////////////////////////////////
			
			function makeTextSprite( message, parameters )
			{
				if ( parameters === undefined ) parameters = {};
				
				var fontface = parameters.hasOwnProperty("fontface") ? 
					parameters["fontface"] : "Arial";
				
				var fontsize = parameters.hasOwnProperty("fontsize") ? 
					parameters["fontsize"] : 18;
				
				var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
					parameters["borderThickness"] : 1;
				
				var borderColor = parameters.hasOwnProperty("borderColor") ?
					parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
				
				var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
					parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };
			
				var spriteAlignment = THREE.SpriteAlignment.topLeft;
					
				var canvas = document.createElement('canvas');
				var context = canvas.getContext('2d');
				context.font = fontsize + "px " + fontface;
				
				// get size data (height depends only on font size)
				var metrics = context.measureText( message );
				var textWidth = metrics.width;
				
				// background color
				context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
											  + backgroundColor.b + "," + backgroundColor.a + ")";
				// border color
				context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
											  + borderColor.b + "," + borderColor.a + ")";
			
				context.lineWidth = borderThickness;
				roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
				// 1.4 is extra height factor for text below baseline: g,j,p,q.
				
				// text color
				context.fillStyle = "rgba(0, 0, 0, 1.0)";
			
				context.fillText( message, borderThickness, fontsize + borderThickness);
				
				// canvas contents will be used for a texture
				var texture = new THREE.Texture(canvas) 
				texture.needsUpdate = true;
			
				var spriteMaterial = new THREE.SpriteMaterial( 
					{ map: texture, useScreenCoordinates: false, alignment: spriteAlignment } );
				var sprite = new THREE.Sprite( spriteMaterial );
				sprite.scale.set(100,50,1.0);
				return sprite;
			}
			
			//////////////////////////////////
			//////// ROUND RECTANGLES ////////
			//////////////////////////////////
			
			function roundRect(ctx, x, y, w, h, r) 
			{
				ctx.beginPath();
				ctx.moveTo(x+r, y);
				ctx.lineTo(x+w-r, y);
				ctx.quadraticCurveTo(x+w, y, x+w, y+r);
				ctx.lineTo(x+w, y+h-r);
				ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
				ctx.lineTo(x+r, y+h);
				ctx.quadraticCurveTo(x, y+h, x, y+h-r);
				ctx.lineTo(x, y+r);
				ctx.quadraticCurveTo(x, y, x+r, y);
				ctx.closePath();
				ctx.fill();
				ctx.stroke();   
			}
			
			//////////////////////////////////
			////////// CLICK EVENT ///////////
			//////////////////////////////////
			
			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				//

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );

				var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );


				if ( SELECTED ) {

					var intersects = raycaster.intersectObject( plane );
					SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
					return;

				}


				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

						plane.position.copy( INTERSECTED.position );
					

					}

					container.style.cursor = 'pointer';

				} else {

					if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

					container.style.cursor = 'auto';

				}

			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );

				var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					

					SELECTED = intersects[ 0 ].object;

					var intersects = raycaster.intersectObject( plane );
					offset.copy( intersects[ 0 ].point ).sub( plane.position );
					controls.enabled = false;

					container.style.cursor = 'move';

				}

			}

			function onDocumentMouseUp( event ) {

				event.preventDefault();

		

				if ( INTERSECTED ) {

					plane.position.copy( INTERSECTED.position );

					SELECTED = null;

				}

				container.style.cursor = 'auto';

			}
			
			function onWindowResize() {
			
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			
				renderer.setSize( window.innerWidth, window.innerHeight );
			
			}

			function animate() {
				
				TWEEN.update();
				requestAnimationFrame( animate );
				controls.update();
				stats.update();
				
				//scene.overrideMaterial = depthMaterial;
				render();

				//scene.overrideMaterial = null;
				//composer.render();

				
			}
			function render() {
	
				renderer.render( scene, camera/*, depthTarget*/ );
			
			}
			
		</script>
	</body>
</html>